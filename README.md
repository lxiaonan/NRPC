# NRPC

## 介绍

一款基于 Netty + Zookeeper + SpringBoot 实现的自定义 RPC 框架。

### 项目实现内容

- [x] 实现基于 Netty进行网路通信
- [x] 自定义消息协议，编解码器
- [x] 五种序列化算法（JDK、GSON、HESSIAN、Xml、Kryo）
- [x] 三种负载均衡算法（RoundRobin、Random）
- [x] 动态代理（JDK）
- [x] 基于 Zookeeper 的服务注册与发现，增加服务本地缓存与监听
- [x] 集成 Spring，自定义注解提供 RPC 服务注册、自动注入
- [x] 集成 SpringBoot，完成自动配置
- [x] 增加 Netty 心跳机制，复用 Channel 连接

----
### RPC概述

RPC 又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。一个最基本的RPC框架的基本架构如下图所示：

![RPC项目架构](image/基本流程图.png)

RPC框架一般必须包含三个组件，分别是**客户端、服务端**以及**注册中心**，一次完整的 RPC 调用流程一般为：

1. 服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）；
2. 客户端会向注册中心订阅相关的服务地址（服务订阅）；
3. 客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流；
4. 客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端；
5. 服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端。

虽然 RPC 调用流程很容易理解，但是实现一个完整的 RPC 框架设计到很多内容，例如服务注册与发现、通信协议与序列化、负载均衡、动态代理等，下面我们一一进行初步地讲解。

## 项目结构介绍


`consumer`模块：服务的消费者，依赖于 `rpc-client-spring-boot-starter` 模块；

`provider-interface`模块：服务提供者暴露的API；

`provider`模块：服务的提供者，依赖于 `rpc-server-spring-boot-starter` 模块：

`rpc-client-spring-boot-stater`模块：rpc 客户端模块，封装客户端发起的请求过程，提供服务发现、动态代理，网络通信等功能；依赖于 `nrpc-core` 模块

`nrpc-core`模块：是rpc核心依赖，提供负载均衡、服务注册发现、消息协议、消息编码解码、序列化算法；

`rpc-server-spring-boo-statert`模块：rpc 服务端模块，负责启动服务，接受和处理RPC请求，提供服务发布、反射调用等功能；

## 项目实现的主要内容

### 自定义消息协议，编解码

既然 RPC 是远程调用，必然离不开网络通信协议。客户端在向服务端发起调用之前，需要考虑采用何种方式将调用信息进行编码，并传输到服务端。因为 RPC 框架对性能有非常高的要求，所以通信协议应该越简单越好，这样可以减少编解码的性能损耗。RPC 框架可以基于不同的协议实现，大部分主流 RPC 框架会选择 TCP、HTTP 协议，出名的 gRPC 框架使用的则是 HTTP2。TCP、HTTP、HTTP2 都是稳定可靠的，但其实使用 UDP 协议也是可以的，具体看业务使用的场景。成熟的 RPC 框架能够支持多种协议，例如阿里开源的 Dubbo 框架被很多互联网公司广泛使用，其中可插拔的协议支持是 Dubbo 的一大特色，这样不仅可以给开发者提供多种不同的选择，而且为接入异构系统提供了便利。

#### 自定义消息协议

自定义协议的要素：

* 魔数，用来在第一时间判定是否是无效数据包
* 版本号，可以支持协议的升级
* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、hessian、jdk
* 指令类型，是请求还是响应或其他跟业务相关
* 请求序号，为了双工通信，提供异步能力，通过这个请求ID将响应关联起来，也可以通过请求ID做链路追踪。
* 正文长度，标注传输数据内容的长度，用于判断是否是一个完整的数据包
* 消息正文，主要传递的消息内容

> 魔数的作用：**快速** 识别[Rpc自定义消息协议](https://blog.csdn.net/m0_62780474/article/details/136244222?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22136244222%22%2C%22source%22%3A%22m0_62780474%22%7D)

本项目设计的消息协议如下：
```
/*
+-----------------------------------------------------------------+
| 魔数 4byte | 协议版本号 1byte | 序列化算法 1byte | 指令类型 1byte    |
+-----------------------------------------------------------------+
| 请求序列 4byte | 状态 1byte | 数据长度 4byte  |  消息 ID 不定        |
+-----------------------------------------------------------------+
*/
```
## 粘包

现象，发送 abc、def，接收 abcdef。
**原因**

- 应用层:接收方 ByteBuf 设置太大(Netty 默认 1024)
- 滑动窗口:假设发送方 256 bvtes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这256 bvtes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包
- Nagle 算法(因为ip和tcp都需要添加报头，使用发的数据很小，也需要消耗大，所以会攒够一批再发送):会造成粘包。

### 解决办法：

方法一：每次发送完一条数据就断开连接，然后再重新连接发送下一条数据

方法二：使用换行符分隔

## 半包

现象，发送 abcdef，接收 abc def
**原因**

- 应用层:接收方 ByteBuf小于实际发送数据量
- 滑动窗口:假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bvtes，等待 ack 后才能发送剩余部分，这就造成了半包
- MSS 限制:当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包

**本质是因为 TCP 是流式协议，消息无边界**

在计算机中，一个十六进制位（hexadecimal digit）可以表示4个比特（bits），也就是半个字节（byte）。因此，两个十六进制位可以表示一个字节。


## LTC解码器


lengthFieldoffset 长度字段偏移量

lengthFieldLength 长度字段长度

lengthAdjustment 长度字段为基准，还有几个字节(还要跳过几个字节)是内容

initialBytesroStrip 从头剥离儿个字节 （解码后，前几个不要的）


**如果产生半包现象，当字段长度还没有读完时，是会继续保留内容，等待下一次消息到来吗**

- 是的，当使用LengthFieldBasedFrameDecoder时，如果产生了半包现象，当字段长度还没有读取完全时，解码器会保留已经接收到的内容，并等待下一次消息到来。这样可以确保数据不会丢失，并且能够正确地拼接组装完整的消息内容。
  然而，要注意的是，**如果下一次到来的消息仍然是一个半包，那么解码器会继续将其与上一次接收到的半包拼接起来，直到读取到一个完整的消息或者达到最大长度限制**。因此，为了避免死循环和资源耗尽，建议在半包处理超时后，抛出异常或者丢弃已经接收到的数据并重新开始接收新的消息。
